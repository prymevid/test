name: Stream Music Video to YouTube

# CONFIGURATION SECTION - Modify these values as needed
env:
  # Video file configuration
  VIDEO_FILE_PREFIX: "k"              # Prefix for video files
  VIDEO_FILE_RANGE_START: 1           # Start of random range for video files
  VIDEO_FILE_RANGE_END: 17            # End of random range for video files
  VIDEO_FILE_EXTENSION: ".mp4"        # Extension for video files
  
  # Stream configuration
  CLOUDFLARE_R2_URL: "https://pub-b19fa9b28a6640638cebf21d187c3e25.r2.dev/new/"  # Base URL for videos
  YOUTUBE_RTMP_URL: "rtmp://a.rtmp.youtube.com/live2/"  # Base RTMP URL for YouTube
  YOUTUBE_STREAM_KEY: "sdf6-cj08-0cbw-5xh4-8kus"        # YouTube stream key
  
  # Runtime configuration (in minutes)
  BASE_RUNTIME: 150                     # Base runtime that will always run
  START_JITTER_MAX: 2                 # Maximum ADDITIONAL random time before starting (0-1 minutes)
  END_JITTER_MAX: 10                   # Maximum ADDITIONAL random time after base runtime (0-2 minutes)
  
  # YouTube preparation delay (in seconds)
  YOUTUBE_PREP_DELAY: 10              # Delay to allow YouTube to prepare for a fresh stream
  
  # FFmpeg settings
  VIDEO_CODEC: "libx264"
  VIDEO_PRESET: "veryfast"
  VIDEO_BITRATE: "1000k"
  AUDIO_CODEC: "aac"
  AUDIO_BITRATE: "96k"
  AUDIO_SAMPLE_RATE: "44100"
  AUDIO_CHANNELS: "2"
  # Additional FFmpeg settings for better streaming
  KEYFRAME_INTERVAL: 60              # Keyframe interval in seconds
  BUFFER_SIZE: "2000k"                # Buffer size for stable streaming

# Trigger configuration - Now uses workflow_dispatch for manual triggering
on:
  workflow_dispatch:  # Allows manual triggering via GitHub UI or API

jobs:
  stream:
    runs-on: ubuntu-latest
    concurrency:
      group: youtube-stream-group  # Ensures only one instance runs at a time
      cancel-in-progress: true     # Cancel any in-progress workflows when a new one starts

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install FFmpeg
        run: |
          echo "üîß Installing FFmpeg..."
          sudo apt update
          sudo apt install ffmpeg -y
          echo "‚úÖ FFmpeg installation completed"

      - name: Generate random video file
        id: random-video
        run: |
          echo "üìπ Selecting a random video file..."
          # Generate a random number within the specified range
          RANDOM_NUM=$(( RANDOM % ($VIDEO_FILE_RANGE_END - $VIDEO_FILE_RANGE_START + 1) + $VIDEO_FILE_RANGE_START ))
          VIDEO_FILE="${VIDEO_FILE_PREFIX}${RANDOM_NUM}${VIDEO_FILE_EXTENSION}"
          echo "video-file=${VIDEO_FILE}" >> $GITHUB_OUTPUT
          echo "‚úÖ Selected video file: ${VIDEO_FILE}"

      - name: Calculate runtime with jitter
        id: runtime
        run: |
          echo "‚è±Ô∏è Calculating stream runtime with jitter..."
          echo "   Jitter is ADDITIONAL random time (in seconds) that will be added to the base runtime"
          
          # Convert max jitter from minutes to seconds
          START_JITTER_MAX_SECONDS=$(( $START_JITTER_MAX * 60 ))
          END_JITTER_MAX_SECONDS=$(( $END_JITTER_MAX * 60 ))
          
          # Calculate start jitter in seconds (randomly select 0 to START_JITTER_MAX_SECONDS)
          START_JITTER_SECONDS=$(( RANDOM % (START_JITTER_MAX_SECONDS + 1) ))
          echo "start-jitter-seconds=${START_JITTER_SECONDS}" >> $GITHUB_OUTPUT
          
          # Calculate end jitter in seconds (randomly select 0 to END_JITTER_MAX_SECONDS)
          END_JITTER_SECONDS=$(( RANDOM % (END_JITTER_MAX_SECONDS + 1) ))
          echo "end-jitter-seconds=${END_JITTER_SECONDS}" >> $GITHUB_OUTPUT
          
          # Convert jitter seconds to minutes with decimal precision for calculation
          START_JITTER_MINUTES=$(echo "scale=2; $START_JITTER_SECONDS / 60" | bc)
          END_JITTER_MINUTES=$(echo "scale=2; $END_JITTER_SECONDS / 60" | bc)
          
          # Calculate total runtime in minutes (with decimal precision)
          TOTAL_RUNTIME=$(echo "scale=2; $BASE_RUNTIME + $START_JITTER_MINUTES + $END_JITTER_MINUTES" | bc)
          
          # For timeout command, we need total seconds
          TOTAL_RUNTIME_SECONDS=$(echo "($BASE_RUNTIME * 60) + $START_JITTER_SECONDS + $END_JITTER_SECONDS" | bc)
          echo "total-runtime-seconds=${TOTAL_RUNTIME_SECONDS}" >> $GITHUB_OUTPUT
          
          # Add a small buffer for graceful termination (3 seconds)
          TIMEOUT_BUFFER_SECONDS=3
          TIMEOUT_SECONDS=$(echo "$TOTAL_RUNTIME_SECONDS + $TIMEOUT_BUFFER_SECONDS" | bc)
          echo "timeout-seconds=${TIMEOUT_SECONDS}" >> $GITHUB_OUTPUT
          
          echo "üìä Runtime Calculation:"
          echo "   Base runtime: ${BASE_RUNTIME} minutes (guaranteed)"
          echo "   Start jitter: ${START_JITTER_SECONDS} seconds (${START_JITTER_MINUTES} minutes)"
          echo "   End jitter: ${END_JITTER_SECONDS} seconds (${END_JITTER_MINUTES} minutes)"
          echo "   Total runtime: ${TOTAL_RUNTIME} minutes (${TOTAL_RUNTIME_SECONDS} seconds)"
          echo "   Timeout buffer: ${TIMEOUT_BUFFER_SECONDS} seconds for graceful termination"
          echo "   Total timeout: ${TIMEOUT_SECONDS} seconds"

      - name: Wait for start jitter
        run: |
          echo "‚è≥ Waiting for ADDITIONAL ${{ steps.runtime.outputs.start-jitter-seconds }} seconds before starting the stream..."
          echo "   (This is the start jitter - random additional wait time in seconds)"
          sleep ${{ steps.runtime.outputs.start-jitter-seconds }}
          echo "‚úÖ Initial wait completed, preparing to start stream"

      - name: Prepare YouTube for fresh stream
        run: |
          echo "üîÑ Preparing YouTube for a fresh stream..."
          echo "   Waiting ${YOUTUBE_PREP_DELAY} seconds for YouTube to be ready..."
          echo "   This ensures any previous stream is fully terminated before starting a new one"
          sleep ${YOUTUBE_PREP_DELAY}
          echo "‚úÖ YouTube preparation delay completed, ready to start streaming"

      - name: Stream Cloudflare R2 video to YouTube
        run: |
          echo "üöÄ Starting stream to YouTube..."
          echo "üì° Stream URL: ${YOUTUBE_RTMP_URL}${YOUTUBE_STREAM_KEY}"
          echo "üìπ Video source: ${CLOUDFLARE_R2_URL}${{ steps.random-video.outputs.video-file }}"
          echo "‚è±Ô∏è Stream will run for exactly ${{ steps.runtime.outputs.total-runtime-seconds }} seconds"
          echo "   (This includes base runtime + all additional jitter time)"
          echo "üé¨ FFmpeg settings:"
          echo "   Video codec: ${VIDEO_CODEC} (${VIDEO_PRESET})"
          echo "   Video bitrate: ${VIDEO_BITRATE}"
          echo "   Audio codec: ${AUDIO_CODEC} (${AUDIO_BITRATE})"
          echo "   Keyframe interval: ${KEYFRAME_INTERVAL} seconds"
          
          # Create a script to handle proper stream termination
          cat > stream_with_termination.sh << 'EOF'
          #!/bin/bash
          
          # Start FFmpeg in the background
          ffmpeg -re -stream_loop -1 \
            -i "${CLOUDFLARE_R2_URL}${VIDEO_FILE}" \
            -c:v ${VIDEO_CODEC} -preset ${VIDEO_PRESET} \
            -g ${KEYFRAME_INTERVAL} -keyint_min ${KEYFRAME_INTERVAL} -sc_threshold 0 \
            -b:v ${VIDEO_BITRATE} -maxrate ${VIDEO_BITRATE} -bufsize ${BUFFER_SIZE} \
            -pix_fmt yuv420p -profile:v baseline -level 3.1 \
            -c:a ${AUDIO_CODEC} -ar ${AUDIO_SAMPLE_RATE} -b:a ${AUDIO_BITRATE} -ac ${AUDIO_CHANNELS} \
            -f flv -flvflags no_duration_filesize \
            "${YOUTUBE_RTMP_URL}${YOUTUBE_STREAM_KEY}" &
          
          FFMPEG_PID=$!
          
          # Wait for the exact calculated runtime
          echo "‚è±Ô∏è Streaming for ${{ steps.runtime.outputs.total-runtime-seconds }} seconds..."
          sleep ${{ steps.runtime.outputs.total-runtime-seconds }}
          
          # Send a graceful termination signal to FFmpeg
          echo "üì° Sending termination signal to FFmpeg..."
          kill -SIGTERM $FFMPEG_PID
          
          # Give FFmpeg time to send the termination signal to YouTube
          sleep 3
          
          # If FFmpeg is still running, force kill it
          if kill -0 $FFMPEG_PID 2>/dev/null; then
            echo "üîß FFmpeg didn't terminate gracefully, force killing..."
            kill -SIGKILL $FFMPEG_PID
          fi
          
          echo "‚úÖ Stream terminated properly"
          EOF
          
          # Make the script executable
          chmod +x stream_with_termination.sh
          
          # Run the script with a timeout as a safety net
          timeout ${{ steps.runtime.outputs.timeout-seconds }}s ./stream_with_termination.sh || \
          echo "‚úÖ Stream completed or terminated after reaching the time limit"

      - name: Notification on completion
        if: always()
        run: |
          echo "üì¢ Stream Status Notification:"
          echo "   Status: ${{ job.status }}"
          echo "   Stream ran for exactly ${{ steps.runtime.outputs.total-runtime-seconds }} seconds."
          echo "   (Base: $((BASE_RUNTIME * 60))s + Start jitter: ${{ steps.runtime.outputs.start-jitter-seconds }}s + End jitter: ${{ steps.runtime.outputs.end-jitter-seconds }}s)"
          echo "   Video streamed: ${{ steps.random-video.outputs.video-file }}"
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Stream completed successfully!"
          else
            echo "‚ùå Stream encountered issues or was terminated unexpectedly."
          fi
